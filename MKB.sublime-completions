{
	"scope": "mkb",

	"completions": 
	[
		{ "trigger": "if\tif…endif", "contents": "if();\n    \nendif;"},
		{ "trigger": "if\tif…elseif…endif", "contents": "if();\n    \nelseif();\n    \nendif;"},
		{ "trigger": "if\tif…else…endif", "contents": "if();\n    \nelse;\n    \nendif;"},
		{ "trigger": "if\tif…elseif…else…endif", "contents": "if();\n    \nelseif();\n    \nelse;\n    \nendif;"},
		{ "trigger": "ifbeginswith\tif…endif", "contents": "ifbeginswith();\n    \nendif;" },
		{ "trigger": "ifbeginswith\tif…elseif…endif", "contents": "ifbeginswith();\n    \nelseif();\n    \nendif;"},
		{ "trigger": "ifbeginswith\tif…else…endif", "contents": "ifbeginswith();\n    \nelse;\n    \nendif;"},
		{ "trigger": "ifbeginswith\tif…elseif…else…endif", "contents": "ifbeginswith();\n    \nelseif();\n    \nelse;\n    \nendif;"},
		{ "trigger": "ifcontains\tif…endif", "contents": "ifcontains();\n    \nendif;" },
		{ "trigger": "ifcontains\tif…elseif…endif", "contents": "ifcontains();\n    \nelseif();\n    \nendif;"},
		{ "trigger": "ifcontains\tif…else…endif", "contents": "ifcontains();\n    \nelse;\n    \nendif;"},
		{ "trigger": "ifcontains\tif…elseif…else…endif", "contents": "ifcontains();\n    \nelseif();\n    \nelse;\n    \nendif;"},
		{ "trigger": "ifendswith\tif…endif", "contents": "ifendswith();\n    \nendif;" },
		{ "trigger": "ifendswith\tif…elseif…endif", "contents": "ifendswith();\n    \nelseif();\n    \nendif;"},
		{ "trigger": "ifendswith\tif…else…endif", "contents": "ifendswith();\n    \nelse;\n    \nendif;"},
		{ "trigger": "ifendswith\tif…elseif…else…endif", "contents": "ifendswith();\n    \nelseif();\n    \nelse;\n    \nendif;"},
		{ "trigger": "ifmatches\tif…endif", "contents": "ifmatches();\n    \nendif;" },
		{ "trigger": "ifmatches\tif…elseif…endif", "contents": "ifmatches();\n    \nelseif();\n    \nendif;"},
		{ "trigger": "ifmatches\tif…else…endif", "contents": "ifmatches();\n    \nelse;\n    \nendif;"},
		{ "trigger": "ifmatches\tif…elseif…else…endif", "contents": "ifmatches();\n    \nelseif();\n    \nelse;\n    \nendif;"},
		{ "trigger": "foreach\tforeach…next", "contents": "foreach();\n    \nnext;"},
		{ "trigger": "foreach\tforeach…break…next", "contents": "foreach();\n    break;\nnext;"},
		{ "trigger": "for\tfor…next", "contents": "for();\n    \nnext;"},
		{ "trigger": "for\tfor…break…next", "contents": "for();\n    break;\nnext;"},
		{ "trigger": "unsafe", "contents": "unsafe(100);\n    \nendunsafe;"},
		{ "trigger": "do\tdo…loop", "contents": "do();\n    \nloop;"},
		{ "trigger": "do\tdo…while", "contents": "do();\n    \nwhile;"},
		{ "trigger": "do\tdo…until", "contents": "do();\n    \nuntil;"},
		{ "trigger": "trim\tremoves whitespace", "contents": "&result = trim(%&string%);"},
		{ "trigger": "shuffle\tshuffles an array", "contents": "shuffle(array[]);"},
		{ "trigger": "eval\tevaluates an expression", "contents": "[&result =] eval([&result],<expression string>);"},
		{ "trigger": "char\tputs set unicode value into &char", "contents": "char(<&char>,<decimal unicode value>);"},
		{ "trigger": "mod\tevaluates num1 modulo num2", "contents": "mod(<#result>,<num1>,<num2>);"},
		{ "trigger": "oldname\tgets the past names of a user", "contents": "oldname(<&names[]>,<username>);"},
		{ "trigger": "readfile\tgets the content of a file", "contents": "readfile(<&content[]>,<filename>);"},
		{ "trigger": "unix\tgets the s/ms of current timestamp", "contents": "[#seconds =] unix([#seconds],[#milliseconds]);"},
		{ "trigger": "adddocs\tadds documentation for action", "contents": "adddocs(<name of entry>,[usage],[description],[return type]);"},
		{ "trigger": "listdocs\treturns documentation of action", "contents": "&docs[] = listdocs([name]);"},
		{ "trigger": "calcyawto\t+ y argument for pitch", "contents": "calcyawto(<xpos>,<ypos>,<zpos>,[#yaw],[#dist],[#pitch]);"},
		{ "trigger": "getslotitem\t+ nbt argument", "contents": "getslotitem(<slotid>,<&itemid>,[#stacksize],[#datavar],[&nbt]);"},
		{ "trigger": "logto\t+ relative and absolute paths", "contents": "logto(<file>,<str>);"},
		{ "trigger": "http\tcreates a http request", "contents": "&response = http([get|post|put|delete],<url>,[output stream],[headers]);"},
		{ "trigger": "iffileexists\tchecks if a file exists", "contents": "iffileexists(<path>,[expression if file should be created if missing]);"},
		{ "trigger": "mkdir\tcreates directory", "contents": "mkdir(<path>);"},
		{ "trigger": "readfile\treads file into array", "contents": "<&content[]> = readfile([&content[]],<path>);"},
		{ "trigger": "writefile\twrites array to file", "contents": "writefile(<path>,<&writefile[]>,[append]);"},
		{ "trigger": "getjsonasarray\treturns json as key:value array", "contents": "&array[] = getjsonasarray(<json>,[format]);"},
		{ "trigger": "getjsonkeys\tretuns list of the keys of json", "contents": "&keys[] = getjsonkeys(<json>);"},
		{ "trigger": "jsonget\tretuns object of key of specified json", "contents": "&object = jsonget(<json>,<key>);"},
		{ "trigger": "sort\tsorts the arrays synchronously", "contents": "sort([asc,dsc],<array[]>,[array[]],...);"},
		{ "trigger": "teammembers\tlists scoreboard team members", "contents": "<&members[]|&teams[]> = teammembers([team]);"},
		{ "trigger": "score\treturns score of player in objective", "contents": "<&score|&scores[]|&obectives[]> = score([objectivename],[playername]);"},
		{ "trigger": "countdownto\tcountdown to the specified datetime", "contents": "countdownto(<until>);"},
		{ "trigger": "countdownfrom\tcountdown from the specified time", "contents": "countdownfrom(<start>);"},
		{ "trigger": "countup\tcreates a countup from the current time", "contents": "countup();"},
		{ "trigger": "counter\tcurrent value of the countdown or countup", "contents": "counter(<id>);"},
		{ "trigger": "sectotime\tformats the amount of seconds to time", "contents": "&time = sectotime(<seconds>,[format]);"},
		{ "trigger": "getchestname\treturns the name of the open chest", "contents": "&name = getchestname;"},
		{ "trigger": "getemptyslots\treturns empty slots in inventory", "contents": "#slots = getemptyslots([include non full slots]);"},
		{ "trigger": "getmouseitem\tgets info about the held item", "contents": "[&id] = getmouseitem([&idvar],[#stacksizevar],[#datavar],[&nbt]);"},
		{ "trigger": "getslotinv\tgets slot containing item in inventory", "contents": "[#slot] = getslotinv(<item[:damage],<#idvar>,[startfromslotid]);"},
		{ "trigger": "ifinvisfull\tchecks if inventory is full", "contents": "ifinvisfull([item]);"},
		{ "trigger": "ifenchanted\tchecks if the item is enchanted", "contents": "ifenchanted(<slot>,[&item],[#stacksize],[#datavar],[&nbt]);"},
		{ "trigger": "setslotitem\tset the contents of a hotbar slot", "contents": "setslotitem(<item[:damage]>,<slot>,[amount],[nbt]);"},
		{ "trigger": "getfishhook\tget the x, y and z (3dp) of the bobber", "contents": "[#ytotal =] getfishhook([#x],[#xprecision],[#y],[#yprecision],[#z],[#zprecision]);"},
		{ "trigger": "notify\tcreates a system tray", "contents": "notify([title],[message]);"},
		{ "trigger": "getslotitemext\t+ argument for the itemname of item", "contents": "[&itemid =] getslotitemext(<#slotid>,[itemid],[stacksize],[damage],[itemname]);"},
		{ "trigger": "getslotitemnbt\t+ argument for the nbt of item", "contents": "[&itemid =] getslotitemnbt(<#slotid>,[itemid],[stacksize],[damage],[nbt]);"},
		{ "trigger": "getslotitemenchants\t+ argument for enchantments", "contents": "[&itemid =] getslotitemenchants(<#slotid>,[itemid],[stacksize],[damage],[enchants]);"},
		{ "trigger": "isboolean\tchecks if the value is a boolean", "contents": "[bool] = isboolean(<string>,[bool]);"},
		{ "trigger": "isfloat\tchecks if the value is a float", "contents": "[bool] = isfloat(<string>,[bool]);"},
		{ "trigger": "isinteger\tchecks if the value is an integer", "contents": "[bool] = isinteger(<string>,[bool]);"},
		{ "trigger": "isjsonarray\tchecks if the value is a json array", "contents": "[bool] = isjsonarray(<string>,[bool]);"},
		{ "trigger": "isjsonobject\tchecks if the value is a json object", "contents": "[bool] = isjsonobject(<string>,[bool]);"},
		{ "trigger": "isjsonprimitive\tchecks if value isjson primitive", "contents": "[bool] = isjsonprimitive(<string>,[bool]);"},
		{ "trigger": "isnumber\tchecks if the value is a number", "contents": "[bool] = isnumber(<string>,[bool]);"},
		{ "trigger": "isstring\tchecks if the value is a string", "contents": "[bool] = isstring(<string>,[bool]);"},
		{ "trigger": "jsonadd\tadds key and value to the json", "contents": "[&output] = jsonadd(<json>,<key>,<value>,[&output]);"},
		{ "trigger": "jsonget\tgets value of a key", "contents": "[&output] = jsonget(<json>,<key>,[&output]);"},
		{ "trigger": "jsonhas\treturns if the json contains the key", "contents": "[bool] = jsonhas(<json>,<key>,[bool]);"},
		{ "trigger": "jsonremove\tremoves a key-value-pair from the json", "contents": "[&output] = jsonremove(<json>,<key>,[&output]);"},
		{ "trigger": "getjsonkeys\treturns list of all keys of the json", "contents": "[&keys] = getjsonkeys(<json>,[&keys[]]);"},
		{ "trigger": "getjsonarray\treturns json as key:value array", "contents": "[&array] = getjsonasarray(<json>,[&array[]]));"},
		{ "trigger": "jsonarrayadd\tadds an element to the json array", "contents": "[&jsonarray] = jsonarrayadd(<jsonarray>,<element>,[&jsonarray]);"},
		{ "trigger": "jsonarrayget\treturns the element of the jsonarray", "contents": "[&output] = jsonarrayget(<jsonarray>,<index>,[&output]);"},
		{ "trigger": "jsonarraysize\treturns the size of the jsonarray", "contents": "[#size] = jsonarraysize(<jsonarray>,[#size]);"},
		{ "trigger": "getclipboard\treturns content of clipboard", "contents": "getclipboard([&text]);"},
		{ "trigger": "setclipboard\tsets the clipboard text", "contents": "setclipboard(<text>);"},
		{ "trigger": "httpget\thttpget request to url", "contents": "[&response[]] = httpget(<url>,<query>,<#status>,[&response]);"},
		{ "trigger": "httppost\thttppost request to url with data", "contents": "[&response[]] = httppost(<url>,<data>,<#status>,[&response]);"},
		{ "trigger": "httpput\thttpput request to url with data", "contents": "[&response[]] = httpput(<url>,<data>,<#status>,[&response]);"},
		{ "trigger": "httpdelete\trequest to specified url", "contents": "[&response[]] = httpdelete(<url>,<query>,<#status>,[&response]);"},
		{ "trigger": "urlencode\turl encodes the string", "contents": "[&output] = urlencode(<string>,[&output]);"},
		{ "trigger": "setrequestheader\tsets header for next request", "contents": "setrequestheader(<&field>,<&value>);"},
		{ "trigger": "gethitsigntext\treturns signtext of hit sign", "contents": "[&outarray] = gethitsigntext([&outarray]);"},
		{ "trigger": "getsigntext\treturns signtext at coordinates", "contents": "[&outarray] = getsigntext(<x>,<y>,<z>,[&outarray]);"},
		{ "trigger": "setsigntext\tset text of sign in SP", "contents": "setsigntext(<x>,<y>,<z>,<line1>,<line2>,<line3>,<line4>);"},
	]
}